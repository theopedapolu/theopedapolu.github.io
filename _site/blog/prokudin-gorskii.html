<!DOCTYPE html>

<!--
  portfolYOU Jekyll theme by yousinix
  Free for personal and commercial use under the MIT license
  https://github.com/yousinix/portfolYOU
-->

<html lang="en" class="h-100">

<head>

  
  
  

  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Colorizing the Prokudin-Gorski Image Collection">
  <meta property="og:description" content="Beware the infinite loop of procrastination. TODO: Write a clever welcome message">
  <meta property="og:image" content="https://i.postimg.cc/vTPwH7kx/profile.jpg">

  <title>Colorizing the Prokudin-Gorski Image Collection</title>
  <meta name="description" content="Beware the infinite loop of procrastination. TODO: Write a clever welcome message">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">

  <!-- Theme style -->
  <script src="/assets/js/theme.js"></script>

  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">

  <!-- Bootstrap CSS CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">

  <!-- Animate CSS CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">

</head>


<body class="h-100 d-flex flex-column">

  <main class="flex-shrink-0 container mt-5">
    <nav class="navbar navbar-expand-lg navbar-themed">

  <a class="navbar-brand" href="/"><h5><b>Theophilus Pedapolu</b></h5></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <i class="fas fa-1x fa-bars text-themed"></i>
  </button>

  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav ml-auto"><a class="nav-item nav-link " href="/projects/">Projects</a>

      <a class="nav-item nav-link active" href="/blog/">Blog</a>

      <a class="nav-item nav-link " href="/about/">About</a>

      

      <span id="theme-toggler" class="nav-item nav-link" role="button" onclick="toggleTheme()"></span>
    </div>
  </div>

</nav>
    <div class="col-lg-10 mx-auto mt-5 markdown-body">
  <h1><b>Colorizing the Prokudin-Gorski Image Collection</b></h1>

<p class="post-metadata text-muted">
  15 September 2023 -  
  <b>6 mins read time</b>

  <br>Tags: 
    
    <a class="text-decoration-none no-underline" href="/blog/tags#computation">
      <span class="tag badge badge-pill text-primary border border-primary">Computation</span>
    </a>
    
    <a class="text-decoration-none no-underline" href="/blog/tags#photography">
      <span class="tag badge badge-pill text-primary border border-primary">Photography</span>
    </a>
    </p>

<h2 id="background">Background</h2>

<p>Sergei Mikhailovich Prokudin-Gorskii was a Russian photographer who
travelled the Russian Empire from 1909 to 1915, documenting many aspects
of the country using his three-image photography method. He recorded
three images of each scene, using a red, green, and blue filter in the
hopes that Russian schoolchildren could learn about their country one
day by viewing these photographs in color. Some of these RGB glass plate
negatives were eventually purchased by the Library of Congress and are
now available publicly. The process of colorizing the photographs,
however, is harder than just superimposing the 3 filtered images since
each image is slightly displaced due to the method by which the photos
were taken. In this project, I automate the process of aligning the 3
images to produce a single colorized photograph. I also employ
techniques from image processing to make the color photographs look
cleaner and “better”</p>

<h2 id="single-scale-alignment-algorithm">Single-Scale: Alignment Algorithm</h2>

<p>The core of my algorithm is pretty simple. I considered the blue-filter
image to be fixed and aligned the red-filter and green-filter images to
it via the following process. For each aligning image, I exhaustively
search over a window of possible displacements ([-20,20] pixels to be
specific) on both the x and y axes and use the normalized
cross-correlation metric (NCC) to score each displacement. The
displacement with the best score is what I eventually shift the image by
to properly align it. One of the problems I ran into early on, however,
was that this naive method produced alignments that were slighly off;
you could see the blue, red, and green filters vary visibly in the final
colorized photo. To fix this problem, for each displacement I cropped
20% off the border of both the aligning image and the fixed image so
that the NCC metric would only be computed on the innermost parts of the
images. This worked much better since we decreased the excess noise in
the NCC metric caused by mismatched borders. The results of this
single-scale alignment algorithm can be seen below:</p>

<p><strong>Note:</strong> <em>In captions for images, R[x,y] means the red-filter image
was displaced by x pixels horizontally and y pixels vertically to align
it to the blue filter. Similarly, G[x,y] means the same for the
green-filter image</em></p>

<h2 id="faster-search-image-pyramid">Faster Search: Image Pyramid</h2>

<p>For larger .tif images, the single-scale procedure is far too slow since
the window of possible displacements we need to search in is much
larger. As a result, I used an image pyramid which stores smaller,
scaled versions of the original image to make the search faster. For
large images, I recursively rescale the both the aligning image and the
fixed image by a factor of 2 (i.e. half each dimension) 4 times until
the bottom level is reached. At that point, I run the single-scale
alignment algorithm from before on the smaller images using the standard
window of [-20, 20] pixels to estimate the best displacement. Then,
for each return from a lower level, I find a slightly better
displacement estimate by running the single-scale alignment algorithm,
this time with a window of [-3,3] pixels from the displacement
estimate found at the lower level (multiplied by 2 to account for
rescaling). Essentially, this multi-scale image pyramid approach finds a
good estimate for the displacement at the lowest scale and slightly
refines it at each higher scale to get a better final estimate.
Initially, I didn’t refine the estimate at each level and just used the
estimate found at the bottom level (multiplied by 2 at each recursive
return). However, I found that that this method caused the aligned
images to be slightly off, so I implemented refining at each level which
fixed the issue. I also tried different schemes such as increasing the
window size for refinement and varying the window size based on the
scaling at each level, but I found that these methods increased the
computation time sizably or produced results that weren’t much better
than the small window size of [-3,3] pixels. The results of
implementing the multi-scale image pyramid procedure on large images can
be seen below. Decent results were output for every image except
“emir.tif” probably due to significant differences in brightness
between its color channels. In the extra credit section, I explore a way
to use edge detectors to fix this problem with “emir.tif” and even
produce better alignments on other images</p>

<h2 id="bells-and-whistles-extra-credit">Bells and Whistles: Extra Credit</h2>

<h3 id="edge-detection">Edge Detection</h3>

<p>To fix the issue with “emir.tif” and produce better alignment overall,
I modified the single-scale alignment algorithm to run edge detection on
the image first and then search over the displacement window. This has
the effect of computing more accurate NCC metrics since edge detection
eliminates the varying degrees in brightness between channels. I used a
sobel filter to perform edge detection. Overall, aligning after edge
detection gave noticably better results, especially on “emir.tif”</p>

<h3 id="automatic-cropping">Automatic Cropping</h3>

<p>To improve the quality of the images after aligning, I also implemented
automatic cropping of the black, white, and colored borders of the
image. I performed two phases of cropping. First, before aligning the
images, I cropped the black and white borders on each channel. To do
this, I first ran edge detection on the image and, starting from the
center, found bounds for the border of the image in each direction. I
iterated through each row and column until I found one that has a
percentage of “white” pixels above a certain threshold. A pixel was
considered to be “white” if it had a value above a certain threshold
close to 255. This algorithm essentially looked for straight white lines
in the edge detected image, starting from the center. I ran this
cropping procedure to find bounds for every channel of the image and
applied the maximum cropping across the 3 channels at the end. The
second phase of cropping came after the image was aligned. Shifting the
channels after aligning caused colored borders due to the np.roll
function so I cropped the image based on how much it was shifted. This
only left the part of the image that all 3 channels agreed upon.
Overall, automatic cropping worked well and produced significantly more
aesthetic final images</p>

<h3 id="automatic-contrasting">Automatic Contrasting</h3>

<p>To improve the quality of the images after aligning, I implemented
automatic contrasting. This adjusts the intensity of the pixels across
the across the image to achieve an even contrast throughout.
Specifically, I found the intensity <em>minval</em> at the 2nd percentile and
the intensity <em>maxval</em> at the 98th percentile and set all values below
the 2nd percentile to <em>minval</em> and all values above the 98th percentile
to <em>maxval</em>. Then, I “stretched” all values in between via the
following formula: <em>pixel(i,j) = (pixel(i,j) - minval)/(maxval -
minval)</em>. Automatic contrasting produced better looking and sharper
images in general as seen below.</p>

<h2 id="final-image-gallery">Final Image Gallery</h2>

<h3 id="examples-of-my-own-choosing-from-the-collection">Examples of my own choosing from the collection</h3>

<h2 id="references">References</h2>

<p>I referenced the following resources while completing this project:</p>

<p><strong>This stack overflow post detailing how to adjust the contrast of an
image using numpy. I used this post to write the automatic contrast
function:</strong></p>

<p>https://stackoverflow.com/questions/48406578/adjusting-contrast-of-image-purely-with-numpy</p>

<p><strong>This W3 schools tutorial on how to create a image gallery in HTML. I
used parts of the code to create this website:</strong></p>

<p>https://www.w3schools.com/css/css_image_gallery.asp</p>

<p><strong>This Medium blog post on image pyramids. I used this to learn more
about how to construct image pyramids:</strong></p>

<p>https://medium.com/analytics-vidhya/a-beginners-guide-to-computer-vision-part-4-pyramid-3640edeffb00</p>

<p><strong>This documentation on the normalized cross-correlation coefficient. I
used this to write the formula to calculate the NCC metric:</strong></p>

<p>https://xcdskd.readthedocs.io/en/latest/cross_correlation/cross_correlation_coefficient.html</p>




</div>
  </main>
  <footer class="mt-auto py-3 text-center">

  <small class="text-muted mb-2">
    <i class="fas fa-code"></i> with <i class="fas fa-heart"></i>
    by <strong>Theophilus Pedapolu</strong>
  </small>

  <div class="container-fluid justify-content-center"><a class="social mx-1"  href="mailto:theopedapolu@gmail.com"
       style="color: #6c757d"
       onMouseOver="this.style.color='#db4437'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fas fa-envelope fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.github.com/theopedapolu"
       style="color: #6c757d"
       onMouseOver="this.style.color='#333333'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-github fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.linkedin.com/in/theopedapolu/"
       style="color: #6c757d"
       onMouseOver="this.style.color='#007bb5'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-linkedin-in fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.twitter.com/TPedapolu"
       style="color: #6c757d"
       onMouseOver="this.style.color='#1da1f2'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-twitter fa-1x"></i>
    </a>

</div><small id="attribution">
    theme <a href="https://github.com/yousinix/portfolYOU">portfolYOU</a>
  </small>

</footer>

  
  <!-- GitHub Buttons -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<!-- jQuery CDN -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- Popper.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>

<!-- Bootstrap JS CDN -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<!-- wow.js CDN & Activation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.js"></script>
<script> new WOW().init(); </script>

<!-- Initialize all tooltips -->
<script>
$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})
</script>
</body>

</html>