<!DOCTYPE html>

<!--
  portfolYOU Jekyll theme by yousinix
  Free for personal and commercial use under the MIT license
  https://github.com/yousinix/portfolYOU
-->

<html lang="en" class="h-100">

<head>

  
  
  

  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta property="og:type" content="website">
  <meta property="og:title" content="Autostitching &amp; Photo Mosaics">
  <meta property="og:description" content="Experimented with image warping and mosaicing, exploring how to rectify and stitch images using homographies. Derived an affine transformation matrix to tran...">
  <meta property="og:image" content="https://i.postimg.cc/59shz3K6/campanile.jpg">

  <title>Autostitching &amp; Photo Mosaics</title>
  <meta name="description" content="Experimented with image warping and mosaicing, exploring how to rectify and stitch images using homographies. Derived an affine transformation matrix to tran...">

  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico">

  <!-- Theme style -->
  <script src="/assets/js/theme.js"></script>

  <!-- Font Awesome CDN -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">

  <!-- Bootstrap CSS CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css">

  <!-- Animate CSS CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.css">

  <!-- Custom CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">

</head>


<body class="h-100 d-flex flex-column">

  <main class="flex-shrink-0 container mt-5">
    <nav class="navbar navbar-expand-lg navbar-themed">

  <a class="navbar-brand" href="/"><h5><b>Theophilus Pedapolu</b></h5></a>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
    <i class="fas fa-1x fa-bars text-themed"></i>
  </button>

  <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
    <div class="navbar-nav ml-auto"><a class="nav-item nav-link active" href="/projects/">Projects</a>

      <a class="nav-item nav-link " href="/blog/">Blog</a>

      <a class="nav-item nav-link " href="/about/">About</a>

      

      <span id="theme-toggler" class="nav-item nav-link" role="button" onclick="toggleTheme()"></span>
    </div>
  </div>

</nav>
    <div class="col-lg-10 mx-auto mt-5 markdown-body">
  <h2 id="background">Background</h2>

<p>In this part of the project, I explore some interesting applications of image homography like rectification and mosaicing. I derived a least squares solution to the homography matrix and shot pictures of various objects and environments at my house and on the UC Berkeley Campus which I compute the homographies on.</p>

<h2 id="shooting-the-pictures">Shooting the Pictures</h2>

<p>I shot the pictures in this project using my iPhone Camera (iPhone 13 Pro Max) which gave me an initial size and resolution of 4032x3024. However, this size was too large so I later downsampled it to a size of 1200x900 to make computations faster. Furthermore, I used focus and exposure locking (AE/AF) to ensure the settings don’t change across perspectives</p>

<h2 id="recovering-homographies">Recovering Homographies</h2>

<p>We want to recover a 3x3 homography matrix, H, from one set of points to another. Because we have 8 unknowns in H, only 4 pairs of correspondence points are needed to recover it. However, using 4 points makes H unstable and prone to noise so it’s better to have more points and find the best solution using least squares. We can write out an overdetermined system of equations between the correspondence points and find a least squares setup to recover H.</p>

<p><img src="https://i.postimg.cc/76Z729cH/mo1.png" alt="Mosaics" /></p>

<h2 id="image-rectification">Image Rectification</h2>

<p>Having found a way to recover the homography matrix, we can “rectify” images, i.e. warp them so the plane is frontal-parallel. Because we have only one image, we find an object in that image we know is rectangular and define two sets of points: one being the corners of the rectangular object in the image and the other a manually defined forward-facing rectangle in the image plane. Then, we compute the homography between these set of points and warp the image via this homography to make it frontal-parallel. This has the effect of changing our perspective angle on the image</p>

<p><img src="https://i.postimg.cc/yYkP51L1/mo2.png" alt="Mosaics" /></p>

<p>It’s pretty cool that even though the pictures are taken at an angle, we can recover a full-frontal view of the image. Below are the cropped versions of the rectified book and painting images. Notice that we have a much clearer front-facing view of the book and painting than in the original images</p>

<p><img src="https://i.postimg.cc/QCMbjhsq/mo3.png" alt="Mosaics" /></p>

<h2 id="blending-images-into-a-mosaic">Blending Images into a Mosaic</h2>

<p>Using homography, we can also blend multiple images into a mosaic that covers a wider field of perception. Given a set of images and correspondence points from left to right, my procedure for creating a mosaic was first warping each image except the leftmost one into the leftmost one via a homography. Then, we have a set of warped images of the same size (with the actual image in different locations on the plane) that need to be stitched together. I tried many different blending techniques like laplacian pyramids and gaussian alpha channels but the technique that seemed to work best was using a linear gradient mask in the overlapping region. To stitch two images together, this involved first calculating the overlapping region then creating a linear gradient mask that goes from 1 to 0 in this region column-wise. Then I create a left mask and a right mask, where the left mask contains the area of the left image but replaced with the linear gradient mask in the overlapping region and the right mask contains the area of the right image but replaced with the inverse of the linear gradient mask (goes from 0 to 1 instead) in the overlapping region. Then, I calculated the stitched image as left_mask<em>left_image + right_mask</em>right_image. This has the effect of keeping the left and right images in regions where they are exclusive but creaing a smooth transition from the left to the right in the region they overlap. I found that this technique also elimiates edge artifacts which were common in the other techniques I explored.</p>

<p><img src="https://i.postimg.cc/CMv7mBHr/mo4.png" alt="Mosaics" />
<img src="https://i.postimg.cc/7hQN6dZr/mo5.png" alt="Mosaics" />
<img src="https://i.postimg.cc/rw49Vh67/mo6.png" alt="Mosaics" />
<img src="https://i.postimg.cc/Pr94ng7m/mo7.png" alt="Mosaics" /></p>

<h1 id="project-4-part-b-feature-matching-for-autostitching">Project 4 Part B: Feature Matching for Autostitching</h1>

<h2 id="background-1">Background</h2>

<p>In part B of this project, I create a system for automatically stitching images into mosaics, without requiring human input for point correspondences. We largely follow the algorithm outlined in this paper <a href="https://inst.eecs.berkeley.edu/~cs180/fa23/hw/proj4/Papers/MOPS.pdf">Multi-Image Matching using Multi-Scale Oriented Patches by Brown et al.</a> which involves detecting the harris corners, using adaptive non-maximal suppression to restrict and ensure the points are spatially well-distributed, extracting and matching feature descriptors for each point, and finally using RANSAC to compute a robust homography estimate between the images. At the end, I show some examples of images that were automatically stitched using this method</p>

<h2 id="detecting-harris-corners">Detecting Harris Corners</h2>

<p>First, we need to find salient features in each image so we have something good to match. We use the Harris detector to find corners in each image. The detector identifies corners by testing the change in intensity across the different directions from a point. If the point is a corner, it changes significantly in intensity across multiple directions. If it changes significantly in only one direction, the point is on an edge.</p>

<p><img src="https://i.postimg.cc/G2dKSv5V/mo8.png" alt="Mosaics" /></p>

<p>Mathematically, we find the SSD between an image patch around the original point and a patch around the shifted point. We can approximate this SSD using matrix Taylor expansion to get the equation below. Finally, to calculate the response for a point, we use the response equation below. When R is large and postive, both eigenvalues are large, meaning the SSD has large shifts in all directions and the point is a corner. We implement Harris Corner Detection using the provided <code class="language-plaintext highlighter-rouge">harris.py</code> code.</p>

<p><img src="https://i.postimg.cc/wv22K7Kv/mo9.png" alt="Mosaics" /></p>

<p><img src="https://i.postimg.cc/0jrpLndW/mo10.png" alt="Mosaics" /></p>

<h2 id="adaptive-non-maximal-suppression">Adaptive Non-Maximal Suppression</h2>

<p>Because the computational cost of matching is high, it is beneficial to restrict the number of interest points used. However, we also want to ensure that the points are spatially well-distributed since the area of overlap between two images may be small. Therefore, we use the adaptive non-maximal suppression algorithm outlined in the paper to select a smaller number of interest points for the image. The algorithm works by calculating a radius, r_i for each interest point by finding the distance to the closest point in a 3x3 window whose harris response is sufficiently higher than the interest point’s response. Then, we take the <em>n</em> interest points with the highest radii. This ensures we only reject points with small radii, which are already “covered” by other interest points. For this project, I used <em>n = 100</em> points</p>

<p><img src="https://i.postimg.cc/mDmYXJM1/mo11.png" alt="Mosaics" /></p>

<p><img src="https://i.postimg.cc/8c3hDvZ1/mo12.png" alt="Mosaics" /></p>

<h2 id="extracting-feature-descriptors">Extracting Feature Descriptors</h2>

<p>Now that we have interest points for each image, we can compute feature descriptors for each point to be used in matching later. Again following the paper, we compute a feature descriptor for an interest point by taking a 40x40 image patch around the point and rescaling it to a size of 8x8. We then normalize the entire patch so it has a mean of 0 and standard deviation of 1. This makes the descriptors have consistent computations when we later match them. In the feature descriptor images below, each feature descriptor was re-normalied to be between 0 and 1 for viewing purposes</p>

<p><img src="https://i.postimg.cc/XNDKwM4T/mo13.png" alt="Mosaics" /></p>

<h2 id="matching-feature-descriptors-and-outlier-rejection">Matching Feature Descriptors and Outlier Rejection</h2>

<p>Next, we match the feature descriptors across two images to come up with a robust selection of point pairs. For matching, we use the nearest neighbors method (NN) with Lowe thresholding. For each point <em>p</em> in the first image with feature descriptor <em>f~p~</em>, we calculate the SSD with every feature descriptor in the other image, recording the smallest (<em>p_1_nn</em>) and second-smallest (<em>p_2_nn) matches</em>. Then, we reject <em>p</em> if <em>p_1_nn/p_2_nn &gt; ε</em> for some threshold <em>ε</em> because this would mean <em>p</em> does not have many strong matches in the other image so it probably doesn’t lie in the overlapping area. If <em>p</em> is not rejected, we match it with its nearest neighbor in the other image and remove that neighbor from the other image’s set of interest points so that we do not have a double match to the same point. We perform this process for every interest point in the first image. At the end, we are left with a set of point correspondences between the two images</p>

<p><img src="https://i.postimg.cc/yNXX9k8P/mo14.png" alt="Mosaics" /></p>

<h2 id="homography-via-ransac">Homography via RANSAC</h2>

<p>The last part of the process is to compute a robust homography estimate between the two images using the point correspondences we derived. To do this, we use the RANSAC algorithm. We randomly select 4 point pairs between the images and compute an exact homography estimate on these pairs (since the homography matrix has exactly 8 unknowns). Then we count the number of inliers, i.e. the number of point pairs that are described well by this homography matrix. We loop through these steps for some number of iterations (I used <em>1000</em> iterations), recording the largest set of inlier pairs found over all iterations. Finally, we compute a final homography estimate via least squares on this largest inliers set. RANSAC works because with enough iterations, there is a good chance that a well-defining set of 4 pairs is chosen at some point in the loop, especially with a lot of correspondences in the overlapping region. These 4 pairs would define a good homography estimate which is later refined by least squares.</p>

<p><img src="https://i.postimg.cc/QMrJHphC/mo15.png" alt="Mosaics" /></p>

<h2 id="autostitching-mosaics">Autostitching Mosaics</h2>

<p>After automatically computing a homography between two images, we can warp them and stitch them together to form a mosaic. We perform this autostitching on the 3 sets of images we used for mosaics in the previous part. We also apply the same gaussian mask blending we used in the previous part to ensure a smooth transition between images and no edge artifacts</p>

<p><img src="https://i.postimg.cc/4dfv1sKT/mo16.png" alt="Mosaics" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>Overall, this was an interesting project and I enjoyed working through it, though the image stitching portion of image mosaicing was quite cumbersome :(. A cool thing I learned is that homographies cannot “create” information. A lot of times, I expected the homography to make it look like I actually changed perspective but this would require additional information that isn’t in the image. The homography simply lets us warp the image to make it look as close to shifting perspective as possible without adding information.</p>

</div>
  </main>
  <footer class="mt-auto py-3 text-center">

    <small class="text-muted mb-2">
      <i class="fas fa-code"></i> with <i class="fas fa-heart"></i>
      by <strong>Theophilus Pedapolu</strong>
    </small>
  
    <div class="container-fluid justify-content-center"><a class="social mx-1"  href="mailto:theopedapolu@gmail.com"
       style="color: #6c757d"
       onMouseOver="this.style.color='#db4437'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fas fa-envelope fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.github.com/theopedapolu"
       style="color: #6c757d"
       onMouseOver="this.style.color='#333333'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-github fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.linkedin.com/in/theopedapolu/"
       style="color: #6c757d"
       onMouseOver="this.style.color='#007bb5'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-linkedin-in fa-1x"></i>
    </a><a class="social mx-1"  href="https://www.twitter.com/TPedapolu"
       style="color: #6c757d"
       onMouseOver="this.style.color='#1da1f2'"
       onMouseOut="this.style.color='#6c757d'">
      <i class="fab fa-twitter fa-1x"></i>
    </a>

</div>
  
  </footer>

  
  <!-- GitHub Buttons -->
<script async defer src="https://buttons.github.io/buttons.js"></script>

<!-- jQuery CDN -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<!-- Popper.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js"></script>

<!-- Bootstrap JS CDN -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

<!-- wow.js CDN & Activation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.js"></script>
<script> new WOW().init(); </script>

<!-- Initialize all tooltips -->
<script>
$(function () {
    $('[data-toggle="tooltip"]').tooltip()
})
</script>
</body>

</html>